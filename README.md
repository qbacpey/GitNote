# Git笔记

## 跟踪新文件

在谈论各种各样的东西之前，我们需要先达成一个共识。git中针对文件状态的认识是基于`.git`的上一级目录的也就是说，不在`.git`的上一级目录（及其递归目录）的都不会被git进行追踪（track）

### git中文件四种不同状态

#### Untracked

这指的是，在当前工作目录下的，尚未被git跟踪的文件。如果我们想让某个文件被git跟踪，只需要：

~~~ Linux
$ git add (filename)
~~~

这时候我们令git开始跟踪这个文件。不过这个文件的功能实际上不止这些：
> 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。

此外，`git add`不仅能将文件名作为参数（从而跟踪这个文件）还能以目录作为参数，从而递归的跟踪这个目录下的所有文件

#### Stage

在缓存区中的文件会被git跟踪，在缓存区中执行：

~~~Linux
$ git commit (filename)
~~~

就会将缓存区中的文件提交到git的仓库中，这时候文件就成了`Unmodified`状态

#### Unmodified

此状态的文件就是根据git的日志得出尚未被修改的文件，我们也可以从此状态将文件`remove`就是将文件变为`Untracked`状态。而在文件被修改之后，文件就会变为`Modified`状态

#### Modified

略

### 检查文件的状态——使用`git stage`

#### 同一个文件的状态

这一部分主要是介绍基于`git stage`下同一个文件能有什么状态

1.Untracked files：指的是在当前工作目录下存在，但是在之前的任意一次`commit`中没有这些文件。也就是说，git检索仓库中的文件之后得出结论：当前目录中存在如下的尚未被追踪的文件
2.up-to-date：这指的是所有已跟踪文件在上次提交之后都未被更改过，并且当前目录下也没有任何尚未被git跟踪的文件
3.Changes to be committed：这指的是处于暂存状态的文件，这时候如果执行`commit`就会将暂存区的文件提交到git的仓库中
4.Changes not staged for commit：暂未被缓存的更改。即当前目录中存在状态为`Modified`的文件

注意，实际上文件是能够同时出现在缓存区和本地目录中的，也就是说，有可能git仓库中的文件，缓存区的文件，本地目录中的文件都不一样。这时候文件就会显得同时出现在缓存区和非缓存区中一样。而且这时候如果对文件执行`commit`的话，会将最后一次对文件执行`add`的文件（也就是缓存区中的文件）提交到git仓库中

这时候，我们只需要再执行一次`add`，用本地的新版本覆盖掉*stage*中的旧版本再执行提交就行了

#### 如何理解`git stage`的输出？

> $ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
> ?? LICENSE.txt

### 忽略一些文件

我们可以通过创建一个名为`.gitignore`的文件，在其中以glob的各式书写所要忽略的文件。符合在其中书写的文件的格式的文件将会被忽略（不管是git还是github），下面是一些例子：

> **\*.a** \#忽略所有的 .a 文件
\
**!lib.a** \#但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
\
**/TODO** \#只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
\
**build/** \# 忽略任何目录下名为 build 的文件夹
\
**doc/\*.txt** \# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
\
**doc/\*\*/\*.pdf** \# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件

另外，不同的子目录也能有他们自己的`.gitignore`文件，虽然一般来说都是由根目录下的`.gitignore`递归作用于后来的所有目录

### 比较文件的不同

通过使用`git diff`我们能回答以下两个问题：
1.磁盘中的哪些更新未暂存
2.已暂存的哪些更新尚未提交

其中，如果我们想要比较磁盘中的文件和暂存区的文件，可以直接使用`git diff`，不加参数的此命令能够比较**自上次暂存以来，此文件发生了什么变化**

如果使用`git diff --staged`比较的就是**已被暂存的文件和最后一次提交的文件**

另外，除了使用`git diff`我们也可以使用`git difftool`来使用插件来比较文件有什么不同

### 提交更新

提交更新是记录的是放在暂存区的快照，每一次运行提交操作，都是对项目本身做的一次快照，之后能回到这个状态，或者对提交的文件进行比较

### 移除文件

使用`git rm`我们能将文件从暂存区中移除（实际上就是相当于令git不再追踪此文件）同时也能从磁盘中删除此文件

相对的，如果我们仅仅想让git不再跟踪此文件并将其从git仓库中删除，就可以使用`git rm --cached`这样git就会不再追踪此文件，但是并不会修改磁盘中的文件，而只会将仓库中的对应文件删除

### 重命名文件

在git中重命名文件直接使用`git rm file1 file2`即可，要注意的是，我们还需要将更改提交到仓库才能将仓库中的文件完成重命名

## 查看日志

本小结将围绕查看日志展开：

|  参数   | 作用  |
|  ----  | ----  |
| -p  | 按照补丁的形式显式每次提交的差异 |
| --stat  | 能够以总结的形式表示每次提交的差异 |
| --pretty  | 可以使用不同的形式显示日志 |
| --format  | 能定制日志的格式,可以理解为C中的printf函数 |
| --shortstat  | 仅显示--stat中最后的行数修改和移除统计 |
| --name-only | 仅在提交信息之后显示已修改的文件清单 |
| --graph | 图形化显示分支和合并历史 |
| --since,--after | 显示指定时间之后的提交 |
| --until,--before | 显示指定时间之前的提交 |
| --author | 仅显示作者匹配指定字符串的提交 |
| --commit | 仅显示提交者匹配指定字符串的提交 |
| --grep | 仅显示提交信息(就是-m相关的内容)中包含指定字符串的提交 |
| -S | 仅显示添加或删除指定字符串的提交 |
| --no-merge | 不显示合并提交 |

## 撤销操作

### 修补（而不是覆盖）上次提交

`git commit --amend`命令一般用于对上次提交的小修小改，这并不等同于直接覆盖上次的提交（也就是提交记录中并不会出现上次的提交记录），在git的眼里，会让上次提交好像**从未发生过**一样

### 恢复到上一次提交的文件

`git checkout -- <file>`能将本地文件覆盖为最后一次提交的文件，我们可以通过此命令将文件恢复成上一次提交的样子

## 分支系统及Git中文件的结构

### 文件的结构

不同于其他的文件管理系统，git中保存文件的方式不是通过分别保存文件的更改，而是将整个当前的工作目录当做一个小型的文件系统来保存。更确切的说：

#### 文件-blob对象

对于文件本身，git会为被将提交到暂存区的文件计算校验和（以此为基准判断文件是否相同）并将此校验和放入暂存区文件夹中，与此同时，git会将文件本身以快照的形式保存到git的本地仓库中（尽管是以git特有的blob对象的方式储存）

#### 目录-tree对象

至于目录，在commit的时候，git会为工作目录及其所有子目录创建嵌套的树对象，并通过树对象来保存（被提交到暂存区的）目录结构信息和其中相关的文件信息（体现为blob文件的指针）
其中，对于那些基于上次提交或暂存之后尚未被修改的文件（应是基于校验Hash值进行判断），在tree对象的创建过程中并不会再为此文件创建相应的blob对象，取而代之的，是保存git仓库中旧blob对象的指针

#### 提交-commit对象

尽管我们已经将磁盘中的工作目录转换成了能被git处理的tree对象，但是，一个可用性高的版本管理文件不应止步于此，除了维护文件本身的信息，我们还需要不同**提交**的信息（也就是元信息，即能说明这次提交的日期，原因，目的，成果）
为此commit对象中不仅会使用tree对象的指针来维护文件，也会保留这次提交的相关信息，以便git系统能以一种更加方便的方式来管理代码

### 分支系统

#### commit对象之间的关系

不同的commit对象之间实际上只有一种关系：commit对象只会维护其父commit对象的指针。为此，如果我们穿透被git良好管理分支系统，直视各个commit对象之间的关系，我们会发现：
1.同一个commit对象可以有多个子commit对象，这些commit对象都指向同一个祖先对象（feature & issue & fixed）
2.程序的不同发行版之间的关系可以看做是基于同一个父commit对象的兄弟commit对象（feature & master）
3.一个commit对象可以有多个父commit对象（merge）
4.有非常多的commit对象只有一个父commit对象，他们也因此呈现为链状（ver1.0 -> ver2.0 -> ver3.0）

其实，上边的commit对象结构实际上就覆盖了我们对一个版本管理软件所有的需求：
1.能基于一个版本派生出不同的发行版
2.能专门为修复问题从稳定版本新建一个修复版本，待修复完成后，和原稳定版本合并为新稳定版本
3.能基于某个版本不断迭代

那么，git将会如何维护这些复杂的关系呢？

#### 使用分支指针来维护它们

分支到底是什么？Git 的分支，其实本质上仅仅是指向提交对象的可变指针。这实际上说明了：
1.分支指针是git用来**呈现**发行版对象之间关系的抓手。就如我们所看到的那样，不管有没有分支指针，commit对象之间的关系还是那样。只不过git通过分支指针，让commit对象之间的关系变得更加清晰明了
2.分支指针可以根据需要，修改分支中文件的版本并不会产生过大的开销。更进一步，分支指针只不过是我们看待某一堆相关的commit对象的一个角度：这一堆commit对象是feature版本，这一堆commit对象是stable版本...总的来说，git中的分支实际上就是某个commit对象，只不过我们通过使用分支指针的方式为这个commit对象赋予了一定的特殊含义而已
3.HEAD指针是指向分支指针的指针。这实际上就是git系统用来标识**当前所在分支**所用的方法，经过分支系统的“筛选”，我们就不用直接面对一堆commit对象发愁了

基于以上优点，在基于某个分支进行版本迭代的时候，我们并不会影响原commit对象及其相应分支，而是基于原commit对象创建新commit对象的同时，将分支指针移动到这个新的commit对象上，进而呈现出：我们基于原版本，检出了一个新的分支版本

另外，Git 在切换分支的时候会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和那个分支最后一次提交时的样子一模一样。因此，如果当前工作目录中没有尚未提交的更改，检出到新的分支可能会被git阻止

#### 混合操作

实际上，git之所以仅记录父commit指针，主要是为了能随时寻找恰当的合并基础（译注：即共同祖先）这主要是因为很多时候我们会执行三方合并（基于某个共同的父commit对象，将其feature分支合并到某个因修复issue而迭代数次的master版本上）这时候，如果我们对程序的同一部分做出不一样的修改，就会引发冲突，git会以以下形式要求用户解决冲突：
> $ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
\
Unmerged paths:
  (use "git add \<file>..." to mark resolution)
\
    both modified:      index.html
\
no changes added to commit (use "git add" and/or "git commit -a")
>
Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：
> <<<<<<< HEAD:index.html
\<div id="footer">contact : email.support@github.com</div>
=======
\<div id="footer">
 please contact us at support@github.com
\</div>
\>>>>>>> iss53:index.html

这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。为了解决冲突，**你必须选择使用由\=======分割的两部分中的一个，或者你也可以自行合并这些内容**。例如，你可以通过把这段内容换成下面的样子来解决冲突：
> \<div id="footer">
please contact us at email.support@github.com
\</div>

当解决完所有冲突（即将文件修改完毕之后），可以对每个发生冲突的文件使用`git add`命令来标记冲突已解决
另外，分支合并完并不意味着被合并进来的分支消失了，与其说是消失，还不如说是停留在了其原来的地方，而新合并形成的分支就是原来的master分支加上feature分支的特性，从而呈现为master分支向前移动了一个commit对象

### 分支开发工作流

#### 长期分支

这种分支管理方式只有一条流水线。在流水线的较早部分是master（稳定版本），较后部分是next（前瞻版本）

#### 主题分支

主题分支指的是针对不同的开发主题（feature & issue & hotfix）随时从稳定版本中派生出不同的分支，然后随时寻找机会合并，本质上和长期分支并无不同，只不过这种形式的分支管理更为复杂些，而长期分支中只有稳定和前瞻的区别

### 远程分支

#### fetch命令

这个命令查找 “origin” 是哪一个服务器（在本例中，它是\git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置
换句话来说，fetch命令的作用只是在本地维护一个远程跟踪分支，确保其能与服务器上的相关信息同步

#### 远程跟踪分支

远程跟踪分支能在本地反映最后一次和服务器通信之后，远程仓库上的指针所指向的提交。也就是说这是一个用户无法移动的本地引用，一旦使用`git fetch`进行网络通信之后，git就会自动更新这个远程跟踪分支的位置，进而反映当前远程服务器上的分支状态

鉴于远程分支指针的特性，可能会出现：
1.远程服务器上的版本经过数次迭代，其上的master分支已经迭代到了ver3.0，而本地的远程分支指针还停留在ver2.0
2.本地基于ver2.0的分支开发出了feature版本，使用fetch同步内容之后，远程分支指针和本地的master指针基于ver2.0出现了分歧

#### 本地跟踪分支

鉴于远程跟踪分支是不可用于修改的只读分支，而我们也会有基于远程仓库修改其中代码的需要，本地跟踪分支便应运而生了。本地跟踪分支跟踪的对象实际上就是远程跟踪分支，通过本地跟踪分支，我们能在保留对服务器端数据跟踪的同时，客制化我们自己的相关数据，具体来说，我们可以这样做：
1.直接使用`clone`，将远程服务器上的整个仓库克隆下来，并创建一个本地跟踪分支master
2.使用`git checkout --track origin/branch`直接在本地创建一个同名的本地跟踪分支
3.使用`git checkout -b sf origin/branch`基于远程分支origin/branch创建本地跟踪分支sf

另外，`git pull`将会使用服务器端的数据更新此本地跟踪分支跟踪的远程跟踪分支，并将远程跟踪分支合并到本地跟踪分支上

#### 推送分支

使用`git push`

## 变基（rebase）

### 什么是变基操作

这个概念实际上即基于由于三方合并所带来的并不简洁的日志所引起的，变基操作会将基于某个节点的更改提取出来成为临时文件，并"重新播放"在指定的"基"上，从而让日志看起来就像是一条直线，原本基于某个节点做出的更改好像从未发生过一样

因此，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

### 变基操作的弊端

鉴于变基操作实际上是丢弃某些提交从而使得日志显得整洁，因此使用变基操作有一条很重要的前提：**只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作**因为让其他人基于*从未存在*过提交进行开发是非常不合理的吧？
